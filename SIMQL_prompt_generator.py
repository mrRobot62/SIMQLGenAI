import json
import random
from datetime import datetime
import os 
import sys
from modules.utils import *
import argparse

class PromptGenerator:
#    def __init__(self, input_path:str, input_file:str, output_path:str):
    def __init__(self, args):
        """
        Initialisiert die PromptGenerator-Klasse.

        :param json_data: Die JSON-Struktur als Python-Dictionary.
        :param prompt_type: Der Typ, der generiert werden soll (z.B. "mmp").
        """
        #self.data = json_data
        self.input_path = args.input_path
        self.input_file = os.path.join(self.input_path, args.input_file)
        self.output_path = args.output_path
        self.output_file_template = args.output_file
        self.prompt_path = args.output_path
        self.prompt_types = args.prompt_types
        self.number_of_rows = int(args.number_of_rows)
        self.prompts = []
        self.links = []
        self.options_intro1 = []
        self.options_intro2 = []
        self.options_intro3 = []
        self.options_reference = []
        self.options_mpref1 = []
        self.options_mpref2 = []
        self.options_mpref3 = []
        self.options_refdate = []
        self.optoins_refdate2 = []
        self.useable_refdates = []
        self.useable_ranges = []
        self.math_agg = []
        self.code = ""
        self.template = ""
        self.verbose = args.v

    def run(self):
        for p_type in self.prompt_types:
            # da eine Liste übergeben wurde als "String" muss nun jetzt jedes
            # Element evaluiert werden - sonst erhält mal soetwas: "'mmp'"
            p_type = eval(p_type)
            fname = self.output_file_template.format(ts=get_timepart(), prompt_type=p_type)
            self.generate_content(prompt_type=p_type, number_of_rows=self.number_of_rows,output_file=fname )

    def generate_content(self, prompt_type:str, number_of_rows=1, output_file="prompt_mmps.txt"):
        """ 
        Generiert den tatsächlichen Prompt-Content und speichert diesen

        :param prompt_type Angabe für den zu generierenden Type (mmp, mp2,mp3,mp4)
        :param number_of_rows Anzahl der Datensätze die generiert werden sollen für den angegebenen typ
        :return Array von generierte prompts
        """
        self.prompt_type = prompt_type
        self.prompt_file = os.path.join(self.prompt_path, output_file)


        # Aktuelles Datum und Uhrzeit inkl. Millisekunden abrufen
        #now = datetime.now()
        
        # Zeit als numerischer Wert inkl. Millisekunden formatieren
        rnd = int(random.uniform(100,9999))
        #time_part = now.strftime("%Y-%m-%d %H:%M:%S")  # yyyymmddhhmmss
        time_part = get_timepart("%Y-%m-%d %H:%M:%S")

        content = [
            {"comment":"#------------------------------------------------------------------------------"},
            {"comment":"# autogenerated prompte file"},
            {"comment":f"# generated {time_part}"},
            {"comment":"#------------------------------------------------------------------------------"},
        ]
        self.data = self._load_input_data(self.input_file)
        #
        # dies Strukturen sind zum variablen generieren von prompts notwendig
        #
        self.useable_refdates = self.data["useable_refdates"]
        self.useable_ranges = self.data["useable_ranges"]
        self.useable_math = self.data["useable_math"]
        self.synonyms = self.data["synonyms"]
        #
        # basierend auf prompt_type werden interen Listen initialisiert
        self._prepare_internal_data_lists()

        for id in range(number_of_rows):
            if len (self.links) > 0:
                for link_list in self.links:
                    print(f"({id:5d}) Generiere Prompts basierend auf LINKS: {link_list}")
                    # prompt wird basierend auf die Anzahl der angegebenen Links aufgebaut
                    # '{0}\n{1}\n{2}' (Beispiel für drei links)
                    self.prompts = '\n'.join([f'{{{i}}}' for i in range(len(link_list))])
                    if len(link_list) > 0:
                        #
                        # Wenn mit link_list gearbeitet wird, wird alles für jeden angegebenen Link (=prompt_typ) ein Prompt generiert
                        # und als Inhalt in die variable {link n} eingetragen.
                        #
                        # Beispiel: link_list = ['mmp','mp2','ld2_refdate']
                        #           {"prompts" : ["{link1}\n{link2}\n{link3}"]},
                        #
                        # Ergebnis: Es wird ein Prompt für MMP, MP2, LD2_REFDATE erzeugt. MMP wird in {link1}, MP2 in {link2}, ... eingetragn
                        #
                        # Effekt: es kann so ein sehr vielfältige Generierung von komplexeren Prompts generiertt werden
                        link_prompts = []
                        orig_prompt_type = self.prompt_type
                        orig_prompts = self.prompts
                        for i, link in enumerate(link_list):
                            self.prompt_type = link
                            self._prepare_internal_data_lists()

                            gp = self._generate_prompt()
                            # es wurde ein kompletter prompt inkl. Code erzeugt
                            # benötigt wird aber nur der eigentliche Prompt
                            link_prompts.append(gp["prompt"])


                        #self.prompts = orig_prompts
                        this_prompt = orig_prompts
                        gp = this_prompt.format(*link_prompts)

                        
                        #
                        # nun nochmals für den original-prompttype code/template nachladen
                        self.prompt_type = orig_prompt_type
                        self._prepare_internal_data_lists()
                        complex_prompt = {
                            "prompt" : gp,
                            "template" : self.template,
                            "code" : self.code
                        }
                        if self.verbose > 2:
                            print(f"{complex_prompt}")
                        content.append(complex_prompt)

            else:
                content.append(self._generate_prompt())
        
        #
        # vermeide doppelte prompts
        content, number_of_prompts = remove_duplicates_by_prompt(content)

        content.append(
            {"comment":"#<END>-------------------------------------------------------------------------"}
        )
        content.append(
            {"comment":"Generiert wurden '{number_of_prompts}' eindeutige prompts"}
        )
        content.append(
            {"comment":"#------------------------------------------------------------------------------"}
        )
        self._save_to_file(content, self.prompt_file)
        print (f"Neues Prompt-File erstellt: '{self.prompt_file}' mit {number_of_prompts} unique Prompts")

        return content



    def _load_input_data(self, file_path):
        """
        Liest eine JSON-Datei und gibt deren Inhalt als Dictionary zurück.

        :param file_path: Der Pfad zur JSON-Datei.
        :return: Ein Dictionary mit dem Inhalt der JSON-Datei.
        """
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)  # Lädt den Inhalt der JSON-Datei als Dictionary
            return data
        except FileNotFoundError:
            print(f"Die Datei {file_path} wurde nicht gefunden.")
        except json.JSONDecodeError:
            print(f"Die Datei {file_path} enthält kein gültiges JSON-Format.")
        except Exception as e:
            print(f"Ein Fehler ist aufgetreten: {e}")

    def _prepare_internal_data_lists(self):
        """
        Lädt die notwendigen Daten basierend auf dem angegebenen Typ.
        """
        if self.prompt_type in self.data:
            if self.verbose > 1:
                print(f"Generate Prompts zum Typ: '{self.prompt_type}'")
            for item in self.data[self.prompt_type]:
                if "intro1" in item:                             # wird generell bei allen prompts genutzt
                    self.options_intro1 = item["intro1"]
                elif "intro2" in item:                           # zweite möglichkeit für eine Start-Sequenz
                    self.options_intro2 = item["intro2"]
                elif "intro3" in item:                           # dritte möglichkeit für eine Start-Sequenz
                    self.options_intro3 = item["intro3"]
                elif "reference" in item:                       # wird generell bei allen prompts genutzt
                    self.options_reference = item['reference']
                # elif "refdate" in item:                     # für Stichtags-Angaben
                #     self.options_refdate = item['refdate']
                # elif "refdate2" in item:                     # für Stichtags-Angaben
                #     self.options_refdate2 = item['refdate2']
                elif "links" in item:                           # wenn gesetzt, werden diese Daten im Prompt mit verwendet
                    self.links = item["links"]
                elif "mpref1" in item:                     # wird in der Regel bei Verwendung von Templates genutzt oder komplexeren Zusammenhang
                    self.options_mpref1 = item['mpref1']
                elif "mpref2" in item:                     # wird in der Regel bei Verwendung von Templates genutzt oder komplexeren Zusammenhang
                    self.options_mpref2 = item['mpref2']
                elif "mpref3" in item:                     # wird in der Regel bei Verwendung von Templates genutzt oder komplexeren Zusammenhang
                    self.options_mpref3 = item['mpref3']
                elif "prompts" in item:                         # Möglicher Prompt
                    self.prompts = item["prompts"]
                elif "code" in item:                            # SIMQL Code (in der Regel kurze Code-Schnipsel)
                    self.code = item["code"]
                elif "template" in item:                        # Verweis auf ein SIMQL-Template
                    self.template = item["template"]

    def _generate_prompt(self):
        """
        Generiert einen zufälligen Prompt basierend auf den gegebenen Optionen und Vorlagen.

        :param mmp_name: Der Name des MetaMesspunkts, der in den Vorlagen verwendet werden soll.
        :return: Ein Dictionary mit 'prompt', 'template' und 'code' Inhalten.
        """

        # Wähle zufällig eine intro1-Option und einen Prompt
        intro1_choice               = (random.choice(self.options_intro1) if len(self.options_intro1) >0 else "")
        intro2_choice               = (random.choice(self.options_intro2) if len(self.options_intro2) >0 else "")
        intro3_choice               = (random.choice(self.options_intro3) if len(self.options_intro3) >0 else "")
        ref_choice                  = (random.choice(self.options_reference) if len(self.options_reference) >0 else "")
        useable_refdates_choice     = (random.choice(self.useable_refdates) if len(self.useable_refdates) >0 else "")
        useable_ranges_choice       = (random.choice(self.useable_ranges) if len(self.useable_ranges) >0 else "")

        mpref1_choice  = (random.choice(self.options_mpref1) if len(self.options_mpref1) >0 else "")
        mpref2_choice  = (random.choice(self.options_mpref2) if len(self.options_mpref2) >0 else "")
        mpref2_choice  = (random.choice(self.options_mpref3) if len(self.options_mpref3) >0 else "")

        prompt_template = random.choice(self.prompts)

        # Ersetze die Platzhalter (falls vorhanden)
        prompt = prompt_template.replace("{intro1}", intro1_choice)
        prompt = prompt.replace("{intro2}", intro2_choice)
        prompt = prompt.replace("{intro3}", intro3_choice)

        prompt = prompt.replace("{reference}", ref_choice)
        prompt = prompt.replace("{refdate}", random.choice(useable_refdates_choice['prompts']))
        prompt = prompt.replace("{range}", random.choice(useable_ranges_choice['prompts']))

        prompt = prompt.replace("{mpref1}", mpref1_choice)
        prompt = prompt.replace("{mpref2}", mpref2_choice)
        prompt = prompt.replace("{mpref3}", mpref2_choice)
        
        code = ""
        try:
            code = self.code.format(
                refdate=useable_refdates_choice['code'],
                range=useable_ranges_choice['code']
            )
        except KeyError as e:
            # an dieser STelle können wir jetzt nicht prüfen ob ein Key im Template 
            # korrekt vorhanden ist.
            # Übernahme des 
            code = self.code 

        generated_prompt = {
            "prompt" : prompt,
            "template" : self.template,
            "code" : code
        }
        if self.verbose > 1:
            print(f"{generated_prompt}")
        return generated_prompt

    def _save_to_file(self, content, filename):
        """
        Speichert die generierten Inhalte in einer Textdatei.

        :param content: Das Dictionary mit den Inhalten ('prompt', 'template', 'code').
        :param filename: Der Dateiname, unter dem die Inhalte gespeichert werden sollen.
        """
        with open(filename, 'w') as file:
            for item in content:
                if 'comment' in item:
                    file.write(f"{item['comment']}\n")
                else:
                    file.write(f"prompt: {item['prompt']}\n")
                    file.write(f"template: {item['template']}\n")
                    file.write(f"code: {item['code']}\n|\n")

        file.close()

#generator = PromptGenerator(input_path="genai_training/misc", input_file="simql_prompt_templates.json", output_path="genai_training/prompts")


def parse_arguments():
    """
    Parsed die Kommandozeilenargumente und gibt sie zurück.
    """
    parser = argparse.ArgumentParser(description="Trainingsdatengenerator V2")
    parser.add_argument('--input_path', required=True, help='Pfad zur PROMPT-JSON Augmentationdatei')
    parser.add_argument('--input_file', required=True, help='JSON-Augmentationdatei')
    parser.add_argument('--output_path', required=True, help='Pfad wo die generierte Dateien gespeichert werden')
    parser.add_argument('--output_file', default='prompt_{ts}_{prompt_type}.txt', help="Ausgabedateien die generiert werden (Template-Filename)")
    parser.add_argument('--number_of_rows', type=int, default=10, help='Ungefähre Anzahl an generierten Datensätzen')
    parser.add_argument('--prompt_types', required=True, type=lambda s: s.strip("[]").split(','), help="Liste zu generierenden Prompt-Typs. (siehe JSON-Augmentation-File)")

    parser.add_argument('-v', action='count', help='Verbosity -v -vv -vvv')
    return parser.parse_args()

def main():
    args = parse_arguments()
    
    try:
        generator = PromptGenerator(args)
        generator.run()

    except ValueError as e:
        print(f"Fehler: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()

# Beispielnutzung
#generator = PromptGenerator(input_path="genai_training/misc", input_file="simql_prompt_templates.json", output_path="genai_training/prompts")
#generator.generate_content( prompt_type="mmp", output_file="prompt_mmps.txt", number_of_rows=200)
#generator.generate_content( prompt_type="mp2", output_file="prompt_mp2.txt", number_of_rows=200)
#generator.generate_content( prompt_type="mp3", output_file="prompt_mp3.txt", number_of_rows=100)
#generator.generate_content( prompt_type="mp4", output_file="prompt_mp4.txt", number_of_rows=100)

